#' Calculate the perplexity from a single celda run
#' 
#' Perplexity can be seen as a measure of how well a provided set of 
#' cluster assignments fit the count data being modeled.
#' 
#' Perplexity is defined in LDA as the exp of the log likelihood of the model
#' divided by the total amount of word tokens. The corresponding perplexity
#' for the celda models are derived in their respective model description 
#' documents. These documents will not be made publicly available until 
#' after publication of celda.
#' 
#' @param counts The count matrix modeled in the celdaRun parameter
#' @param celda.mod A single celda run (usually from the _res.list_ property of a celda_list)
#' @param precision The amount of bits of precision to pass to Rmpfr
#' @return The perplexity for the provided chain as an mpfr number
#' @export
calculatePerplexity = function(counts, celda.mod, precision=128) {
  UseMethod("calculatePerplexity", celda.mod)
}


#' Calculate and visualize perplexity of all models in a celda_list, with resampling
#' 
#' Calculates the perplexity (a measure of how well celda's cluster assignments fit the data) for every celda model in a celda_list generated by the celda() function. Perplexity of the cluster assignments given the provided count matrix,
#' as well as resamplings of that count matrix, provide a distribution of perplexities and a better sense of the quality of a given K/L choice. 
#' 
#' @param celda.list A celda_list object as returned from *celda()*
#' @param counts The counts matrix used to generate the provided celda.list
#' @param resample The number of times to resample the counts matrix for evaluating perplexity. Works with method="perplexity."
#' @param title Title to be appended to the perplexity plot title. Default is "".
#' @return A list with a data frame summarizing all of the calculated perplexities, and a ggplot2 object visualizing them.
#' @export
calculatePerplexityWithResampling <- function(celda.list, counts, resample,
                                              title="") {
  if (!isTRUE(class(celda.list) == "celda_list")) stop("celda.list parameter was not of class celda_list.")
  if (!isTRUE(is.numeric(resample))) stop("Provided resample parameter was not numeric.")
  
  countsList = list(counts)
  for(i in 1:resample) {
    countsList[[i]] = resampleCountMatrix(counts)
    i = i - 1  
  }
  
  perplexities.per.model = lapply(celda.list$res.list, function(mod){
    perplexities = lapply(countsList, function(counts, mod){ 
      class(counts) = class(mod)
      UseMethod("calculatePerplexity", object=mod)
    }, mod)
    
    perplexity.df = data.frame(perplexity=unlist(perplexities))
    if (!is.null(mod$K)) { perplexity.df$k = rep(mod$K, nrow(perplexity.df)) }
    if (!is.null(mod$L)) { perplexity.df$l = rep(mod$L, nrow(perplexity.df)) }
    return(perplexity.df)
  })
  
  plot.df = do.call("rbind", perplexities.per.model)
  plot = visualizePerplexity(plot.df)
  return(list(perplexity.info=plot.df, plot=plot))
}


#' Visualize perplexity as a function of cell/gene clustering
#' 
#' This function plots perplexity as a function of the cell/gene (K/L) clusters as generated by celda().
#' It accepts a perplexity dataframe as generated by calculatePerplexityWithResampling(). 
#' 
#' The provided #' data frame should have columns for at least one of K or L 
#' (the clusterings provided by celda()), and a column for the perplexity calculated for 
#' the corresponding chain. 
#' 
#' @param perplexity.df A data.frame as described above, or as returned by calculatePerplexityWithResampling()
#' @param title A subtitle for the plot
#' @return A ggplot plot object showing perplexity as a function of clustering parameters
#' @export
visualizePerplexity = function(perplexity.df, title="") {
  if (!any(c("k", "l") %in% colnames(perplexity.df)) | is.null(perplexity.df$perplexity)) {
    stop("perplexity.df argument needs a perplexity column, and at least one of k or l.")
  }
  
  # First, decide what the discrete X-axis will be...
  if (!is.null(perplexity.df$k)) {
    plot = ggplot2::ggplot(perplexity.df, ggplot2::aes(x=as.factor(k), y=perplexity))
  } else {
    plot = ggplot2::ggplot(perplexity.df, ggplot2::aes(x=as.factor(l), y=perplexity))
  }
  # If we have both K and L, color points by their L, and draw lines between each L across K
  if (!is.null(perplexity.df$k) & !is.null(perplexity.df$l)) { 
    plot = plot + ggplot2::geom_jitter(height=0, width=0.1, 
                                       ggplot2::aes(color=as.factor(perplexity.df$l))) +
          ggplot2::scale_color_discrete(name="L") 
    
    l.means.by.k = setNames(aggregate(perplexity.df$perplexity,
                                    by=list(perplexity.df$k, perplexity.df$l),
                                    FUN=mean),
                          c("k", "l", "mean_perplexity"))
   l.means.by.k$l = as.factor(l.means.by.k$l)
   l.means.by.k$k = as.factor(l.means.by.k$k)
   plot = plot + ggplot2::geom_path(data=l.means.by.k,
                                    ggplot2::aes(x=k, y=mean_perplexity, group=l, color=l))
  } else {
    plot = plot + ggplot2::geom_jitter(height=0, width=0.1)
  }
  plot = plot +  ggplot2::ggtitle(paste("Perplexity for All Provided Chains", "\n", title)) + 
         ggplot2::xlab(ifelse(is.null(perplexity.df$k), "L", "K")) +
         ggplot2::ylab("Perplexity") +
         ggplot2::theme_bw()
  
  return(plot)
}


# Resample a counts matrix for evaluating perplexity
#
# Normalizes each column (cell) of a count matrix by the column sum to 
# create a distribution of observing a given number of counts for a given gene in that cell,
# then samples across all cells.
#
# This is primarily used to evaluate the stability of the perplexity for a given K/L combination.
# 
# @param celda.mod A single celda run (usually from the _res.list_ property of a celda_list)
# @return The perplexity for the provided chain as an mpfr number
resampleCountMatrix = function(count.matrix) {
  colsums  = colSums(count.matrix)
  prob     = t(t(count.matrix) / colsums)
  resample = sapply(1:ncol(count.matrix), function(idx){
                      rmultinom(n=1, size=colsums[idx], prob=prob[, idx])
                   })
  return(resample)
}
