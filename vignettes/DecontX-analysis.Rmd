---
title: "Estimate and remove cross-contamination from ambient RNA for scRNA-seq data with DecontX"
author: "Shiyi Yang, Sean Corbett, Yusuke Koga, Zhe Wang, W. Evan Johnson, Masanao Yajima, Joshua D. Campbell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimate and remove cross-contamination from ambient RNA for scRNA-seq data with DecontX}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction 
DecontX is a Bayesian hierarchical model to estimate and remove cross-contamination from ambient RNA in single-cell RNA-seq count data generated from droplet-based sequencing devices.DecontX will take the count matrix with/without the cell labels and estimate the contamination level and deliver a decontaminted count matrix for downstream analysis. 

In this vignette we will demonstrate how to use DecontX to estimate and remove contamination.  


The package can be loaded using the `library` command.

```{r, eval=TRUE, warning = FALSE, echo = FALSE, message = FALSE}
library(celda)
```
To see the latest updates and releases or to post a bug, see our GitHub page at https://github.com/compbiomed/celda. To ask questions about running Celda, visit our Google group at https://groups.google.com/forum/#!forum/celda-list.


# Generation of a cross-contaminated dataset 
DecontX will take a matrix of counts (referred as observed counts) where each row is a feature, each column is a cell, and each entry in the matrix is the number of counts of each feature in each cell. To illustrate the utility of DecontX, we will apply it to a simulated dataset.

In the function `simulateContaminatedMatrix`, the K parameter designates the number of cell clusters, the C parameter determines the number of cells, the G parameter determines the number of genes in the simulated dataset.

```
sim_counts = simulateContaminatedMatric( G = 300, C = 100, K = 3 ) 
```

The `nativeCounts` is the natively expressed counts matrix, and `observedCounts` is the observed counts matrix that contains both contaminated and natively expressed transctripts. 
```{r}
sim_counts$nativeCounts[1:3,1:5] 
sim_counts$observedCounts[1:3,1:5]
```

The `N.by.C` is the total number of observed transcripts per cell. 
```{r}
length(sim_counts$N.by.C)
```

The counts matrix which only contains contamianted transcripts can be obtained by subtracting the observed counts matrix from the observed counts matrix. 

```
contamination = sim_counts$observedCounts - sim_counts$observedCounts 
```

The `z` variable contains the population label for each cell
```
table( sim_counts$z) 
```

The `phi` and `eta` variables contain the expression distributions and contamination distributions for each population, respectively. Each column corresponds to a population, each row represents a gene. The sum of the rows equal to 1. 
```
colSums( sim_counts$phi ) 
colSums( sim_counts$eta )
```


# Decontamination using DecontX
DecontX uses bayesian method to estimate and remove contamination via varitaional inference. 
```{r, warning = FALSE, message = FALSE}
decontx.model = DecontX( counts = sim_counts$observedCounts, z = sim_counts$z ) 
```

## Check convergance
Use log-likelihood to check convergance 
```{r, eval = TRUE, fig.width = 5, fig.height = 5}
plot( decontx.model$res.list$loglikelihood ) 
```
## Evaluate model performance 
`DecontX` estimates a contamination proportion for each cell. We compare the estimated contamination proportion with the real contamination proportion.
```{r, eval = TRUE, fig.width = 5, fig.height = 5}
plot( decontx.model$res.list$est.conp, colSums(contamination) / sim_counts$N.By.C,  col=sim_counts$z) 
abline( 0, 1) 
```

We can also compare the estimated gene expression vs the true native expression in each cluster. Here we show an example of the comparison the gene expressions of population1
```{r, eval = TRUE, fig.width = 5, fig.height = 5}
normalized.counts = normalizeCounts( decontx.model$res.list$est.nativeCounts, "proportion" ) 
average.expression = t(rowsum( t(normalized.counts), group = sim_counts$z ) ) 
average.expression = normalizeCounts( average.expression, "proportion" ) 
plot(sim_counts$phi[, 1], average.expression[, 1], xlab="native expression", ylab="estimated average expression", main="gene expression in population1" ) 
```
