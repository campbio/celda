---
title: "An Introduction to `celda`"
author: Josh D. Campbell, Sean Corbett, Masanao Yajima, Zichun Liu, Shiyi Yang, Tianwen
  Huan, Anahita Bahri
date: '`r Sys.Date()`'
output:
  pdf_document: default
  html_document: default
vignette: |
  %\VignetteIndexEntry{Vignette Title} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.width=6,fig.height=6 ,
			out.width="0.7\\linewidth", fig.align = "center")
library(RColorBrewer)
library(ggplot2)
library(celda)
library(gtools)
library(pheatmap)
library(reshape2)
library(vcd)
library(corrplot)
library(gtable)
library(scales)


```

# 1 Introduction

`celda` pronounced like "Zelda" is the abbreviation for "CELlular Latent Dirichlet Allocation", which is suite of algorithms and supporting functions for genes and cell clustering  specifically designed to handle single cell RNA sequence data. The algorithm is extention of the Latent Dirichlet Allocation (LDA) topic modeling framework that is popular in Machine Learning.  Single cell RNA data has high affinity with the LDA type mixture of multinomila representation due to the sparsity of discrete counts and high dimension $(n<<p)$ of the data, both of which is a problem in statistical models that assume some type of uni-modal continuous distribution.  Although our primary intent is single cell RNA sequence data, `celda` can handle any data with feature counts such as proteomics or microbiome 16S rRNA data.  In this vignette we will demonstrate how one can perform cellular clustering of single cell RNA seq data using `celda`.  For details of the underlying algoirthm, please see [??].

## Installation

Currently `celda` is hosted on a Github repository `definitelysean/celda`.  Although there are multiple ways to install packages from Github, such as directly downloading the source and locally compiling it, simplest way that we recommend is through the use of `install_github` function in the `devtools` package [cite]. You will need to install the devtools package using `install.packages` function in R.

```{r,eval=FALSE}
install.packages("devtools")
library(devtools)
install_github("definitelysean/celda")
```
This should automatically install `celda` on your local machine as long as you have proper internet connection.  If you encounter a problem during the installation you may want to open up a browser and acces our github repository https://github.com/definitelysean/celda.

## Loading the library

Once installed the package can be loaded using the `library` command.
```{r,eval=FALSE}
library(celda)
```

## Finding the helpfiles
Complete list of help files are accessible using the help command with a `package` option.

```{r,eval=FALSE}
help(package=celda)
```

<!-- The LDA model in `celda` package can be visualized as follows: -->

<!-- \includegraphics[height=7cm]{graph.dot.png} -->

# 2 Analysis Example

We will illustrate how one can perform clustering of single cell RNA sequence data using `celda` starting with a toy example included in the package.
[description of the data]

## 2.1 An Example with built-in Toy dataset 

### 2.1.1 Loading the dataset

The data can be loaded using the `data` command
```{r}
data("sample.cells")
```
, which will load the `sample.cells` into ones work space.  The data is a 10 by 12 matrix of discrete counts as most RNA sequence data are. However, for our illustration purpose the size of the matrix is significantly reduced.

### 2.1.2 Initial Visualization

The data is ordered to highlight the fact that there are four distinct cell clusters (column).
```{r pheatmap_toy_1,fig.width=6,fig.height=5 ,	out.width="0.6\\linewidth", fig.align = "center"}
library(pheatmap)
pheatmap(scale(sample.cells,center = F),cluster_rows = FALSE, cluster_cols = FALSE)
```

<!-- Our sample has 4 types of cell and 4 types of transcriptome states. -->

### 2.1.3 Cellular clustering

The function `celda` is the main function to perform the clustering.  The LDA models are accurate conditional on the number of clusters, meaning when running the algorith one needs to specify the number of clusters.  We will discuss how one might select the number of clusters later but we will start by passing the correct number of cluster which is `K=4`. 
We will run a cell clustering algorithm as follows.

```{r}
toy_celda_cg = celda(sample.cells, model="celda_CG",sample.label = rep(1,12),K = 4, L = 4)
```

What we care most in this result is what are the cluster labels that each of the cells are assigned to.  This can be acessed as

```{r}
toy_celda_cg$res.list[[1]]$z
```
Here `z` is the label for the most likely cluster under this model. As you can see `celda` correctly identified the clusters given this toy model when the correct number of clusters were specified. The numbers indicate the group each cell belongs to and the order of the indices do not have any meanings to them. 

### 2.1.4 Plot heatmap with estimated cell cluster labels

Celda has a heatmap function that allows for semisupervised clustering.  One can specify the cluster labels obtained from the model and within the cluster it will perform hierarchical clustering.

```{r celda_heatmap_toy_1,fig.width=7,fig.height=5 ,	out.width="0.6\\linewidth", fig.align = "center"}
celda_heatmap(celda.mod = toy_celda_cg$res.list[[1]], counts = sample.cells, z.trim = NULL)
```

This is useful in highlighting the source of differences acrss the estimated clusters.

## 2.2 An example using simulation data

### 2.2.1 Generate data using built-in function

`celda` is a generative model therefore it is also easy to generate a data based on the underlying model.   `celda` provides functions to generate simulated data which resembles RNA sequence expression matrix. 

<!-- We can specify some arguments in the function: -->

  <!-- S: Number of Samples -->

  <!-- C.Range: Range of number of cells in a sample  -->

  <!-- N.Range: Range of number of transcripts in a cell -->

  <!-- G: Total number of Gene types -->

  <!-- K: Total number of cell populations -->

  <!-- L: Total number of transcriptional states -->
 
  <!-- alpha: Assuming the type of cell(K types) in S samples follows a multinomial distribution. $\alpha$ is the parameter of its conjugate priors distribution  -->

  <!-- beta: Assuming the type of transcriptional states(L types) in K type of cell follows a multinomial distribution. $\beta$ is the parameter of its conjugate priors distribution that generate that multinomial distribution. -->

  <!-- gamma: Assuming the distribution of a gene contribute to a transcriptional states(L types) is a multinomial distribution. $\gamma$ is the parameter of its conjugate priors distribution that generate that multinomial distribution. -->

  <!-- delta: Assuming the proportion of different types of gene in a transcriptional state  follows a multinomial distribution. $\delta$ is the parameter of its conjugate priors distribution that generate that multinomial distribution.  -->

  <!-- seed: Random seed -->
Here we simulated 100 cells with 100 genes coming from distinct 3 cell clusters.
```{r pheatmap_simulated_1,fig.width=6,fig.height=5 ,	out.width="0.6\\linewidth", fig.align = "center"}
sim_counts = simulateCells.celda_C( G = 100,K = 3)
pheatmap(scale(sim_counts$counts,center = F),cluster_rows = FALSE, cluster_cols = FALSE)
```


<!-- The `cCG.generateCells` will return a list with standard format of celda. In the output: -->

<!--   z: Indicate which kind of cell it is for all cells in all samples -->

<!--   y: Indicate which transcriptional state a gene contributed to  -->

<!--   sample: Indicate which sample a cell is from -->

<!--   counts: In one cell what kind of gene and how many times it worked. (gene -> transcripts -> cell) -->

<!--   theta: Proportion(multinomial distribution) of different types of cells in samples -->

<!--   phi: Proportion(multinomial distribution) of different types of transcriptional states in cells -->

<!--   psi: Proportion(multinomial distribution) of different types of genes in transcriptional states -->

<!--   eta: Probability(multinomial distribution) of a gene contribute to different types of transcriptional states -->


### 2.2.2 LDA Clustering on Cells 

Again we will perform the cellular clustering as a proof of concept.

```{r}
celda_cluster_assignments = celda( sim_counts$counts, model="celda_CG",
                                      sample.label = sim_counts$sample,
                                      K = 3,L = 3,max.iter = 25 )
#str(celda_cluster_assignments)
```

<!-- z: Cell cluster assignments from the final iteration of Gibbs sampling -->

<!-- y: gene cluster assignments from the final iteration of Gibbs sampling  -->

<!-- complete.z: History of cell cluster assignments across all iterations of Gibbs -->

<!-- complete.y: History of gene cluster assignments across all iterations of Gibbs -->

<!-- z.stability: [0,1] measure of stability for the cell clustering chain -->

<!-- y.stability: [0,1] measure of stability for the gene clustering chain -->

<!-- complete.z.stability: History of z.stability over all iterations of Gibbs sampling -->

<!-- complete.y.stability: Historyof y.stability over all iterations of Gibbs sampling -->

<!-- completeLogLik: Log-likelihood of all gene and cell cluster assignments over all iterations of Gibbs sampling -->

<!-- finalLogLik: Log-likelihood of final gene and cell cluster assignments -->

<!-- z.prob: -->

<!-- y.prob: -->

### 2.2.4 Cluster results and visualization

Here is the resulting confusion matrix comparing the true cluster label to the estimated cluster label.
```{r}
estimated.z=celda_cluster_assignments$res.list[[1]]$z
truth.z=sim_counts$z
xtabs(~ estimated.z + truth.z)
#xtabs(~celda_cluster_assignments$y + sim_counts$y)
```
All of the samples line up on the diagonal cell indicating that the estimated labes match the true labels.  This illustrates again that `celda` is able to recover the cluster labels accurately conditional on the correct cluster numbers.

```{r celda_heatmap_simulated_1,fig.width=7,fig.height=5 ,	out.width="0.6\\linewidth", fig.align = "center"}
celda_heatmap(celda.mod = celda_cluster_assignments$res.list[[1]],counts = sim_counts$counts)
```

### 2.2.5 visualization of cluster proportion for the samples

One natural question that arises in practice is whar are the proportion of each sell types for each sample that may or may not belong to different experiment conditions.  `celda` provides function that can produce such a visualization. 
```{r }
#### Heatmap, Mosaic plot and corrplot on Cluster cell data
plot_cell_prop<-function(celda_object, sample_label,type="circle"){
  cluster_z = celda_object$res.list[[1]]$z
  tb = xtabs(~sample_label + cluster_z)
  nmat <- tb/rowSums(tb)
  mnmat<-melt(nmat)
  mnmat$sample_label<-factor(mnmat$sample_label)
  mnmat$cluster_z<-factor(mnmat$cluster_z,levels=sort(unique(mnmat$cluster_z),TRUE))
  myPalette <- colorRampPalette((brewer.pal(9, "Greens")))
  if(type=="circle") corrplot(t(nmat),method = "circle",is.corr = FALSE)
  else{
    ggplot(mnmat)+geom_tile()+
    aes(x=sample_label,y=cluster_z,fill=value)+scale_fill_gradientn(colors=myPalette(100))+
    scale_x_discrete(position = "top")+xlab("sample")+ylab("cluster")
  }
}
plot_cell_prop( celda_cluster_assignments, sample_label = sim_counts$sample)
```

```{r,fig.width=6,fig.height=3 ,	out.width="0.6\\linewidth", fig.align = "center"}
plot_cell_prop( celda_cluster_assignments, sample_label = sim_counts$sample,type="heatmap")
```


# 3 Selecting the number of clusters  (and other diagnostic plots)

## 3.1 Run the toy dataset with celda wrapper with multiple K/L choices
```{r}
celdaCG.res.1 <- celda(counts = sample.cells, model="celda_CG", K=3, L=4)
celdaCG.res.2 <- celda(counts = sample.cells, model="celda_CG", K=4, L=3)
```

## 3.2 Generate plots for K and L selection
```{r}
celda_heatmap(celda.mod = celdaCG.res.1$res.list[[1]],counts = sample.cells)
celda_heatmap(celda.mod = celdaCG.res.2$res.list[[1]],counts = sample.cells)
```

<!-- # 4 Description of different models using toy dataset -->
<!-- ## 4.1 Cells (C) -->
<!-- ```{} -->
<!-- ``` -->

<!-- ## 4.2 Genes (G) -->
<!-- ```{} -->
<!-- ``` -->
Paragtaph

celdaCG faster
<!-- ## 4.3 Cells into populations and Genes into transcriptional states (CG) -->
<!-- ```{} -->
<!-- ``` -->


<!-- # 5 Real dataset example (10X) -->

<!-- ## 5.1 Read in data -->
<!-- ```{r} -->

<!-- ``` -->

<!-- ## 5.2 Filter genes -->
<!-- ```{r} -->

<!-- ``` -->

<!-- ## 5.3 Run celda wrapper -->
<!-- ```{r} -->

<!-- ``` -->

<!-- ## 5.4 Select parameters -->
<!-- ```{r} -->

<!-- ``` -->

<!-- ## 5.5 Plot heatmap -->
<!-- ```{r} -->

<!-- ``` -->


# Appendix
  
```{r,echo=FALSE,eval=FALSE}
modgraph<-'
Digraph fig1 {
rankdir = LR; //order things from left to right

//define alpha and beta as existing
alpha [shape=circle,label=<&alpha;>];
beta [shape=circle,label=<&beta;>];
gamma [shape=circle,label=<&gamma;>];
//not strictly nescessary but helps if you want to
//assign them specific shapes or colours

subgraph cluster_S
{
    label = "S"
    psi [shape=circle,label=<&psi;>];
  psi ->y;

subgraph cluster_M 
{
    label = <M<sub><font point-size="8">s</font></sub>>

 
    y [shape=circle];
    subgraph cluster_N
    {
        label = <N<sub><font point-size="8">ms</font></sub>>
        z [shape=circle];
        x [shape=circle, style=filled]
        z->x; 
    }
  y->z;

}
}
alpha -> theta;
beta -> phi;
gamma ->psi;
  subgraph cluster_L 
  {
      label ="L"
      theta [shape=circle,label=<&theta;>];
    theta -> z;
  }
  subgraph cluster_K
  {
      label = "K"
      phi [shape=circle,label=<&phi;>];
      phi->x;
  }
}

'
con <- file("graph.dot", "w")
cat(modgraph, file=con)
close(con)
#system("dot -Txdot graph.dot| dot2tex > graph.tex")
system("dot -T png -O graph.dot")
```

