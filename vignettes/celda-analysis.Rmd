---
title: "Analyzing single-cell RNA-seq count data with Celda"
author: "Josh D. Campbell, Sean Corbett, Masanao Yajima, Zichun Liu, Shiyi Yang, Tianwen Huan, Anahita Bahri, Yusuke Koga"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# 1 Introduction

"celda" stands for "**CE**llular **L**atent **D**irichlet **A**llocation", which is a suite of Bayesian hierarchical models and supporting functions to perform gene and cell clustering for count data generated by single cell RNA-seq platforms. This algorithm is an extension of the Latent Dirichlet Allocation (LDA) topic modeling framework that has been popular in text mining applications. Celda has advantages over other clustering frameworks:

1) Celda can simultaneously cluster genes into transcriptional states and cells into subpopulations
2) Celda uses count-based Dirichlet-multinomial distributions so no additional normalization is required for 3' DGE single cell RNA-seq
3) These types of models have shown good performance with sparse data.
 
In this vignette we will demonstrate how to perform cell and gene clustering with simulated and real single cell RNA-seq data using the Bayesian hierarchical models within celda. 


## Installation Instructions

Currently `celda` is hosted on a Github repository `compbiomed/celda`.

```{r,eval=FALSE}
library(devtools)
install_github("compbiomed/celda@v0.1")
```

This should automatically install `celda` on your local machine as long as you have proper internet connection.  If you encounter a problem during the installation you may want to open up a browser and acces our github repository https://github.com/compbiomed/celda.

## Loading the library

Once installed the package can be loaded using the `library` command.

```{r,eval=FALSE}
library(celda)
```

## Finding the helpfiles
Complete list of help files are accessible using the help command with a `package` option.

```{r,eval=FALSE}
help(package=celda)
```


# 2. Single cell RNA-seq dataset analysis with celda

We will learn how to use the package `celda` to cluster genes and cells from count data generated in single cell RNA-seq experiments. `celda` will take a matrix of counts where each row is a gene and each cell is a column and each entry in the matrix is the number of counts for each gene in each cell. For this tutorial, we will start with a simple matrix of counts that were simulated according to the generative process behind the `celda_CG` model and then we will apply `celda` to a single-cell RNA-seq dataset of PBMCs.  

```{r,eval=T, warning = FALSE, echo = FALSE}
library(devtools)
library(celda)
library(Matrix)
library(gtools)
library(ggplot2)
```

We use the built-in data generating function `simulateCells.celda_CG` to simulate a single-cell RNA-Seq dataset. `simulateCells.celda_CG` returns a list containing a count matrix where each row is a gene and each column is a cell. The K parameter determines the number of cell clusters while the L parameter determines the number of gene clusters within the dataset.

```{r}
sim_counts = simulateCells.celda_CG(K=3,L=10)
```

The `counts` variable from `simulateCells.celda_CG` contains the counts matrix.
The dimensions of counts matrix:

```{r}
dim(sim_counts$counts)
```

The `z` variable from `simulateCells.celda_CG` contains the cluster for each cell.
Here is the number of cells in each subpopulation:

```{r}
table(sim_counts$z)
```

The `y` variable from `simulateCells.celda_CG` contains the transcriptional state assignment for each gene. 
Here is the number of genes in each transcriptional state:

```{r}
table(sim_counts$y)
```

The sample.label is used to denote the sample from which each cell was derived. In this simulated dataset, we have 10 samples:

```{r}
table(sim_counts$sample.label)
```

Each cell is assumed to come from a sample. Here is the number of cells in each subpopulation within each sample:

```{r}
table(sim_counts$z, sim_counts$sample.label)
```



## 2.1.1 How to Run Celda

There are currently three models within this package: `celda_C` will cluster cells, `celda_G` will cluster genes, and `celda_CG` will simultaneously cluster cells and genes. Here is the command for `celda_CG`:

```{r, fig.show='hold', warning = FALSE, message = FALSE}

celdaCG.res = celda_CG(counts = sim_counts$counts, K =3, L = 10, max.iter = 10, sample.label = sim_counts$sample.label)
```

Here is a comparison between the true cluster labels and the estimated cluster labels.

```{r}
z = celdaCG.res$z
y = celdaCG.res$y

table(z, sim_counts$z)
table(y, sim_counts$y)

```

We can display the clustering results with a heatmap of the normalized counts:

```{r, fig.width = 7, fig.height = 7, warning = FALSE, message = FALSE}
norm.counts <- normalizeCounts(sim_counts$counts)
render_celda_heatmap(counts=norm.counts,z=z,y=y, cluster.column = FALSE, cluster.row = FALSE)
```

## 2.1.2 Matrix factorization

`celda` can also perform matrix factorization to summarize the contribution of each transcriptional state to each cellular subpopulation. 

```{r}
factorized <- factorizeMatrix.celda_CG(counts = sim_counts$counts, celda.obj = celdaCG.res)

pop.states = t(factorized$proportions$population.states)
head(pop.states)
```

These states can also be visualized with a heatmap:

```{r, fig.width = 7, fig.height = 7}
render_celda_heatmap(pop.states, col=colorRampPalette(c("white", "blue"))(70), scale.row=F, show_cellnames=T, show_genenames=T, cluster.column=F, cluster.row=F, breaks = NA, z= 1:3, y = 1:10)
```

Sometimes it may be helpful to visualize the relative probability of each transcriptional state in each cellular subpopulation. We can do this by normalizing the rows of the probability matrix to sum up to 1:

```{r, fig.width = 7, fig.height = 7}
rel.states = sweep(pop.states, 1, rowSums(pop.states), "/")
render_celda_heatmap(rel.states, col=colorRampPalette(c("white","blue"))(70), scale.row=F, show_cellnames=T, show_genenames=T, cluster.column=F, cluster.row=F, breaks = NA, z= 1:3, y = 1:10)
```

The relative probabilities will tend to reflect the patterns observed in the heatmap as the genes in the heatmaps are Z-score transformed and thus on a relative scale as well.

## 2.1.3 Identifying the optimal number of states

The optimal number of K and L will likely not be known a priori. Therefore multiple choices of K and L may need to tested and compared. Additionally, `celda` is sensitive to initial start conditions, so it is good practice to run multiple chains for each combination of K and L to increase the chances of finding the most optimal solution. We have built a wrapper function that will run multiple combinations of K and L with multiple chains for each combination in parallel. 

```{r}
celda.res.list <- celda(counts = sim_counts$counts,K = 2:4, L = 9:11, nchains = 3, max.iter = 10, model = "celda_CG")
```

Here, `celda` will fit the model for every combination of K between 2 and 4 and L between 9 and 11. Three chains will be run for each combination. The parameter "ncores" can be set to something more than 1 to run multiple chains in parallel.

```{r, fig.width = 7, fig.height = 7, message = FALSE}
visualize.model = visualize_model_performance(celda.res.list,method="perplexity")

visualize.model$K
```

Perplexity is a measure of goodness-of-fit for the model where lower perplexity is better. The perplexity of each chain can be visualized as a function of K. In this example, K=3 is much better than K=2, but K=4 does not give much improvement over K=3. We would therefore select K=3 in this case. Note: We are still actively testing various methods for assessing model performance. 

We can use the function "getModel" to select a particular model from the list of models once we have selected the optimal K and L.

```{r}
model = getModel(celda.res.list, K = 3, L = 10, best = "loglik")
```

The chain with the best log likelihood will be returned from all models that were run with K = 3 and L = 10.

# 3. PBMC Analysis with celda

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.align = "center")
library(celda)
library(Matrix)
library(data.table)
library(pheatmap)
library(biomaRt)
```

We will use the "cmatp_data" dataset, which is a dataset of 3000 Peripheral Blood Mononuclear Cells (PBMC), available from 10X Genomics. The rows are organized by gene names, while the columns are organized by barcodes. For this tutorial, the dataset has been slightly modified so the rownames are comprised of the Ensembl gene ID as well as the gene name. The raw dataset can be found at https://support.10xgenomics.com/single-cell/software/pipelines/latest/rkit.

We will only include genes with at least 5 counts in a least 5 cells for this analysis to reduce computational time. However, `celda` is capable of analyzing genes with fewer counts. 

```{r}
load(file="../data/cmatp_data.rda")
dim(cmatp_data)
head(rownames(cmatp_data))
head(colnames(cmatp_data))
```

```{r}
cmatp_select <- cmatp_data[rowSums(cmatp_data>4) > 4,]
```

### 3.1.1 Analysis of 10X Genomics PBMC data


```{r, message = FALSE, verbose = FALSE}
cmatp.res = celda_CG(cmatp_select, sample.label = rep(1,ncol(cmatp_select)), K = 15, L = 20)
```

After matrix factorization, the top genes can be selected using the `topRank` function on the "gene.states" matrix:  

```{r}
factorize.matrix = factorizeMatrix.celda_CG(counts = cmatp_select, celda.obj = cmatp.res)
top.genes <- topRank(factorize.matrix$proportions$gene.states)
```

```{r}
top.genes$names$L16
```

```{r}
top.genes$names$L19
```

We can make a heatmap of these top genes as follows: 

```{r, fig.width = 7, fig.height = 7}
top.genes.ix <- unique(unlist(top.genes$index))
norm.cmatp.counts <- normalizeCounts(cmatp_select)
render_celda_heatmap(norm.cmatp.counts[top.genes.ix,], z = cmatp.res$z, y = cmatp.res$y[top.genes.ix], cluster.row = FALSE, cluster.column = FALSE)
```

We can also summarize the relative contribution of each transcriptional state in each cell population with a heatmap: 

```{r, fig.width = 7, fig.height = 7}
cmatp.states = t(factorize.matrix$proportions$population.states)
cmatp.rel.states = sweep(cmatp.states, 1, rowSums(cmatp.states), "/")
render_celda_heatmap(cmatp.rel.states, col=colorRampPalette(c("white","blue","darkgreen","green"))(100), scale.row=F, show_cellnames=T, show_genenames=TRUE, cluster.column=FALSE, cluster.row=FALSE, breaks = NA, z= 1:15, y = 1:20)
```

