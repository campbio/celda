---
title: "Analyzing single-cell RNA-seq count data with Celda"
author: "Josh D. Campbell, Masanao Yajima, Sean Corbett, Zichun Liu, Shiyi Yang, Tianwen Huan, Anahita Bahri, Zhe Wang, Yusuke Koga, Jiangyuan Liu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
# Introduction
  
  "Celda" stands for "**CE**llular **L**atent **D**irichlet **A**llocation", which is a suite of Bayesian hierarchical models and supporting functions to perform gene and cell clustering for count data generated by single cell RNA-seq platforms. This algorithm is an extension of the Latent Dirichlet Allocation (LDA) topic modeling framework that has been popular in text mining applications. Celda has advantages over other clustering frameworks:
  
1) Celda can simultaneously cluster cells into cell subpopulations and genes into transcriptional states - subgroups of genes that are likely to be expressed in similar proportions -  over different types of cells
2) Celda uses count-based Dirichlet-multinomial distributions so no additional normalization is required for 3' DGE single cell RNA-seq
3) These types of models have shown good performance with sparse data.

In this vignette we will demonstrate how to perform cell and gene clustering with simulated and real single cell RNA-seq data using the Bayesian hierarchical models within Celda. 


## Installation Instructions

Currently Celda is hosted on a Github repository `compbiomed/celda`.

```{r,eval=FALSE}
library(devtools)
source("https://bioconductor.org/biocLite.R")
biocLite("SummarizedExperiment")
biocLite("MAST")
install_github("compbiomed/celda")
```

This should automatically install Celda on your local machine as long as you have proper internet connection.  If you encounter other problems during the installation you may want to open up a browser and access the issues page on our github repository at https://github.com/compbiomed/celda. If you have any other questions or concerns, you could also contact our Google Group at:

Once installed the package can be loaded using the `library` command.

```{r,eval=FALSE}
library(celda)
```

Complete list of help files are accessible using the help command with a `package` option.

```{r,eval=FALSE}
help(package=celda)
```

<br>

# 2. Single cell RNA-seq dataset analysis with Celda

We will learn how to use the package Celda to cluster genes and cells from count data generated in single cell RNA-seq experiments. Celda will take a matrix of counts where each row is a gene and each cell is a column and each entry in the matrix is the number of counts for each gene in each cell. For this tutorial, we will start with a simple matrix of counts that were simulated according to the generative process behind the `celda_CG` model. 

```{r,eval=T, warning = FALSE, echo = FALSE}
library(devtools)
library(celda)
library(Matrix)
library(gtools)
library(ggplot2)
library(Rtsne)
library(reshape2)
```

We use the built-in data generating function `simulateCells` to simulate a single-cell RNA-Seq dataset. `simulateCells` returns a list containing a count matrix where each row is a gene and each column is a cell. The K parameter determines the number of cell clusters while the L parameter determines the number of gene clusters within the dataset. The S parameter determines the number of samples. 

```{r}
sim_counts <- simulateCells("celda_CG", K = 6, L = 6, S = 10)
```

The `counts` variable contains the counts matrix.
The dimensions of counts matrix:

```{r}
dim(sim_counts$counts)
```

The `z` variable contains the cluster labels for each cell.
Here is the number of cells in each subpopulation:

```{r}
table(sim_counts$z)
```

The `y` variable contains the transcriptional state assignment for each gene. 
Here is the number of genes in each transcriptional state:

```{r}
table(sim_counts$y)
```

The sample.label is used to denote the sample from which each cell was derived. In this simulated dataset, we have 10 samples:

```{r}
table(sim_counts$sample.label)
```

Each cell is assumed to come from a sample. Here is the number of cells in each subpopulation within each sample:

```{r}
table(sim_counts$z, sim_counts$sample.label)
```

## 2.1.1 Running the Celda function

There are currently three models within this package: `celda_C` will cluster cells, `celda_G` will cluster genes, and `celda_CG` will simultaneously cluster cells and genes. The `celda` function will use these models and take in a counts matrix to create a `celda.list` object that contains the cluster labels for each cell and gene.

```{r, warning = FALSE, message = FALSE}

celda.res <- celda(counts = sim_counts$counts, model = "celda_CG", K = 6, L = 6, max.iter = 10, cores = 1, nchains = 1)

```

The `celda.list` contains 4 objects: "run.params", "res.list","content.type",and "count.checksum". The Celda model(s) will be stored within the "res.list". 

Here is a comparison between the true cluster labels and the estimated cluster labels.

```{r}
names(celda.res)

model <- celda.res$res.list[[1]]
z <- model$z
y <- model$y

table(z, sim_counts$z)
table(y, sim_counts$y)

```

We can display the clustering results with a heatmap of the normalized counts, obtained by the function `normalizeCounts`, which normalizes a counts matrix by a scalar factor.

```{r, fig.width = 7, fig.height = 7, warning = FALSE, message = FALSE}
norm.counts <- normalizeCounts(sim_counts$counts, scale.factor = 1e6)
renderCeldaHeatmap(counts = norm.counts, z=z, y=y, normalize = NULL, color_scheme = "divergent",cluster_gene = TRUE, cluster_cell = TRUE)
```

## 2.1.2 Matrix factorization

Celda can also perform matrix factorization to summarize the contribution of each transcriptional state to each cellular subpopulation. Matrix factorization decomposes the counts matrix into multiple matrices, using the given Celda model. The gene.states contains each gene's contribution to the transcriptional state it belongs. The cell.states contains each sample's contribution to each transcriptional state. The population.states contains each transcriptional states' contribution to each of the cell states. Each of these matrices can be viewed as raw counts values or proportional values.

```{r}
factorized <- factorizeMatrix(model, sim_counts$count)
```

```{r}
dim(factorized$proportions$gene.states)
head(factorized$proportions$gene.states)
```

```{r}
dim(factorized$proportions$cell.states)
factorized$proportions$cell.states[1:6,1:8]
```

```{r}
pop.states <- factorized$proportions$population.states
dim(pop.states)
```

For instance, roughly 40% of the population in cell state K5 is in transcriptional state L6. 

```{r}
pop.states
```

## 2.1.3 Visualization of the Celda model

Celda contains several plotting tools for data dimensionality reduction tool outputs. The PCA result for the factorized matrix is plotted by the `plotDrCluster` and `plotDrState` function based off of the Celda clusters and state probabilities for each cell respectively:

```{r, fig.width = 7, fig.height = 7}
data.pca <- prcomp(t(scale(t(factorized$proportions$cell.states))),scale = F, center = F)

plotDrCluster(dim1 = data.pca$rotation[,1], dim2 = data.pca$rotation[,2], cluster = celda.res$res.list[[1]]$z)

plotDrState(dim1 = data.pca$rotation[,1], dim2 = data.pca$rotation[,2], matrix = factorized$proportions$cell.states, rescale = TRUE)
```

In addition to the counts matrix, the transcriptional and cell states of a Celda model can also be visualized with a heatmap:

```{r, fig.width = 7, fig.height = 7}
renderCeldaHeatmap(pop.states, color_scheme = "sequential", show_cellnames=T, show_genenames=T, breaks = NA, z= 1:ncol(pop.states), y = 1:nrow(pop.states))
```

Sometimes it may be helpful to visualize the relative probability of each transcriptional state in each cellular subpopulation. We can do this by z-score normalizing the probability matrix:

```{r, fig.width = 7, fig.height = 7}
rel.states <- sweep(pop.states, 1, rowSums(pop.states), "/")
renderCeldaHeatmap(rel.states, color_scheme = "sequential", show_cellnames=T, show_genenames=T, breaks = NA, z= 1:ncol(rel.states), y = 1:nrow(rel.states))
```

The relative probabilities will tend to reflect the patterns observed in the heatmap as the genes in the heatmaps are Z-score transformed and thus on a relative scale as well.


## 2.1.4 Identifying the optimal number of cell subpopulations and transcriptional states

The optimal number of K and L will likely not be known a priori. Therefore multiple choices of K and L may need to tested and compared. Additionally, Celda is sensitive to initial start conditions, so it is good practice to run multiple chains for each combination of K and L to increase the chances of finding the most optimal solution. Celda is able to run multiple combinations of K and L with multiple chains for each combination in parallel. 

```{r, eval = TRUE}
celda.res.list <- celda(counts = sim_counts$counts,K = 5:7, L = 6:7, nchains = 2, max.iter = 10, model = "celda_CG", cores = 1)
```

Here, `celda` will fit the model for every combination of K between 5 and 7 and L between 6 and 7. Two chains will be run for each combination. The parameter "cores" can be set to something more than 1 to run multiple chains in parallel.

The Celda package contains several methods to determine the optimal number of K upon creating the models. `calculatePerplexityWithResampling` calculates the perplexity for every model created, which provide a distribution of perplexities which can be visualized to determine which model to use for downstream analysis. 

```{r, fig.width = 7, fig.height = 7}
calc.perplexity <- calculatePerplexityWithResampling(celda.res.list, counts = sim_counts$counts, resample = TRUE)

visualizePerplexityByKL(calc.perplexity$perplexity.info)
```

The function `gettingClusters` attempts to identify the optimal number for K by looking for differential expression between each cell clusters in a single model. 

```{r, fig.width = 7, fig.height = 7}
cluster.plot.sim <- gettingClusters(celda.list = celda.res.list, matrix = sim_counts$counts, iterations = 3)
cluster.plot.sim
```

For both cases, K = 6 and L = 6 is identified to be the optimal model, which is how the data was simulated.

We can use the function `getBestModel` to select the best model with the highest log-likelihood from the list of models once we have selected the optimal K and L. The replicate with the highest log likelihood will be returned from all models that were run with the selected K and L. 

```{r, eval = FALSE}
model <- getBestModel(celda.res.list, K = 6, L = 8)
```

<br>

# 3. Exploration of the PBMC dataset with Celda

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.align = "center")
library(celda)
library(Matrix)
library(data.table)
library(pheatmap)
library(Rtsne)
```

We will now apply Celda on the "pbmc_data" dataset, which is a single-cell RNA-seq dataset of 3000 Peripheral Blood Mononuclear Cells (PBMC), available from 10X Genomics. The rows are organized by gene names, while the columns are organized by barcodes. For this tutorial, the dataset has been slightly modified so the rownames are comprised of the Ensembl gene ID as well as the gene name. The raw dataset can be found at https://support.10xgenomics.com/single-cell/software/pipelines/latest/rkit.

We will only include genes with at least 5 counts in a least 5 cells for this analysis to reduce computational time. However, Celda is capable of analyzing genes with fewer counts. 

```{r}
dim(pbmc_data)
head(rownames(pbmc_data))
head(colnames(pbmc_data))
```

```{r}
pbmc_select <- pbmc_data[rowSums(pbmc_data>4) > 4,]
```


### 3.1.1 Analysis of 10X Genomics PBMC data


```{r, eval = FALSE}
pbmc_res <- celda(pbmc_select, K = seq(10:30,by = 2), L = c(20,30), cores = 1, model = "celda_CG", nchains = 4, max.iter = 100)
```

Upon running the `celda` function on the filtered pbmc dataset, we will attempt to identify the optimal K:L combination.

```{r, eval = FALSE}
cluster.plot <- gettingClusters(celda.list = pbmc_res, matrix = pbmc_select, iterations = 3)
```

```{r, fig.width = 7, fig.height = 7}
cluster.plot
```

In this example, it appears that K = 20 gives the best model. We have observed a general trend in which a higher number of transcriptional states will result in a higher accurate model; since there is no discernible difference between L = 20 and L = 30, we will choose L = 30. 


```{r}
model.pbmc <- getBestModel(pbmc_res, K = 16, L = 30)
```

`stateHeatmap` creates a heatmap using only the genes from a specific transcriptional state, which enables the visualization of co-expression patterns of genes within the transcriptional state.

```{r, fig.width = 7, fig.height = 7, message=FALSE}
stateHeatmap(counts = pbmc_select, celda.mod = model.pbmc, state.use = 3)
```

Celda supports the tSNE. We can plot tSNE results via `plotDrCluster`, `plotDrState` and `plotDrGene`. These will determine how each cell is labeled via celda, visualize each cell's expression respectively of a specific transcriptional state and visualize each cell's expression of a set of genes. 

```{r, message = FALSE}
factorize.matrix <- factorizeMatrix(model.pbmc, counts=pbmc_select)
norm_pbmc <- normalizeCounts(factorize.matrix$counts$cell.states)
set.seed(123)
pbmc_tsne <- celdaTsne(counts = pbmc_select, celda.mod = model.pbmc, distance = "cosine")
```

With the use of the plots, it is also possible to determine which cell clusters express specific marker genes. 

```{r, fig.width = 7, fig.height = 7}
plotDrCluster(dim1 = pbmc_tsne[,1], dim2 = pbmc_tsne[,2], cluster = as.factor(model.pbmc$z))

plotDrState(dim1 = pbmc_tsne[,1], dim2 = pbmc_tsne[,2], matrix = factorize.matrix$proportions$cell.states, rescale = TRUE)

marker.genes <- c("ENSG00000168685_IL7R","ENSG00000198851_CD3E","ENSG00000105374_NKG7",
                 "ENSG00000203747_FCGR3A","ENSG00000090382_LYZ","ENSG00000179639_FCER1A",
                 "ENSG00000156738_MS4A1", "ENSG00000163736_PPBP")
gene.counts <- pbmc_select[marker.genes,]
plotDrGene(dim1 = pbmc_tsne[,1],dim2 = pbmc_tsne[,2], matrix = gene.counts, rescale = TRUE)
```

Celda employs the `MAST` package [(McDavid A, 2018)](https://bioconductor.org/packages/release/bioc/html/MAST.html) for differential expression analysis of single-cell data. The `diffExpBetweenCellStates` function determines genes that are differentially expressed in one cell subpopulation against all other subpopulations, or between two cell subpopulations.

If you want to compare one cell subpopulation compared to all others, leave c2 as NULL: 

```{r,message=FALSE}
diff.exp.clust1 <- diffExpBetweenCellStates(counts = pbmc_select, celda.mod = model.pbmc, c1 = 1, c2 = NULL)

diff.exp.clust1
```

If you want to compare two cell subpopulations, use both c1 and c2 parameters.

```{r, message=FALSE}
diff.exp.clust1vs2 <- diffExpBetweenCellStates(counts = pbmc_select, celda.mod = model.pbmc, c1 = 1, c2 = 2)

diff.exp.clust1vs2
```


Upon matrix factorization of the counts data, the top genes in a transcriptional state can be selected using the `topRank` function on the "gene.states" matrix:  

```{r}
factorize.matrix <- factorizeMatrix(model.pbmc, counts=pbmc_select)
top.genes <- topRank(factorize.matrix$proportions$gene.states, n = 25)
```

```{r}
top.genes$names$L3
```

```{r}
top.genes$names$L29
```

We can make a heatmap of these top genes as follows: 

```{r, fig.width = 7, fig.height = 7}
top.genes.ix <- unique(unlist(top.genes$index))
norm.pbmc.counts <- normalizeCounts(pbmc_select)
renderCeldaHeatmap(norm.pbmc.counts[top.genes.ix,], z = model.pbmc$z, y = model.pbmc$y[top.genes.ix], normalize = NULL, color_scheme = "divergent")
```

The `GiniPlot` function utilizes the Gini coefficient, a statistical dispersion measure, to determine the significance of each transcriptional states.

```{r, fig.width = 7, fig.height = 7}
gini <- GiniPlot(counts = pbmc_select, celda.mod = model.pbmc)

gini
```

While some transcriptional states contribute to the identification of cell subpopulations, some states have low statistical value to the mode, and users may find it useful to re-create the heatmap using only states that have a high enough Gini coefficient value to create a "cleaner" heatmap. For this example, we will use states that have a Gini coefficient higher than 0.19. This is an arbitrary cutoff, and users can set their own threshold for the cutoff. 


```{r, fig.width = 7, fig.height = 7}
filtered.tr.states <- gini$data$Transcriptional_States[gini$data$Gini_Coefficient > 0.19]

top.genes.filtered.ix <- unique(unlist(top.genes$index[as.numeric(levels(filtered.tr.states))][as.numeric(filtered.tr.states)]))

renderCeldaHeatmap(norm.pbmc.counts[top.genes.filtered.ix,], z = model.pbmc$z, y = model.pbmc$y[top.genes.filtered.ix], normalize = NULL, color_scheme = "divergent")
```

