---
title: "Analyzing single-cell RNA-seq count data with Celda"
author: "Josh D. Campbell, Masanao Yajima, Sean Corbett, Zichun Liu, Shiyi Yang, Tianwen Huan, Anahita Bahri, Zhe Wang, Yusuke Koga, Jiangyuan Liu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
# 1 Introduction
  
  "celda" stands for "**CE**llular **L**atent **D**irichlet **A**llocation", which is a suite of Bayesian hierarchical models and supporting functions to perform gene and cell clustering for count data generated by single cell RNA-seq platforms. This algorithm is an extension of the Latent Dirichlet Allocation (LDA) topic modeling framework that has been popular in text mining applications. Celda has advantages over other clustering frameworks:
  
1) Celda can simultaneously cluster cells into subpopulations and genes into transcriptional states, which are subgroups of genes that are likely to be expressed in similar proportions over different types of cells
2) Celda uses count-based Dirichlet-multinomial distributions so no additional normalization is required for 3' DGE single cell RNA-seq
3) These types of models have shown good performance with sparse data.

In this vignette we will demonstrate how to perform cell and gene clustering with simulated and real single cell RNA-seq data using the Bayesian hierarchical models within celda. 


## Installation Instructions

Currently `celda` is hosted on a Github repository `compbiomed/celda`.

```{r,eval=FALSE}
library(devtools)
install_github("compbiomed/celda")
```

This should automatically install `celda` on your local machine as long as you have proper internet connection.  If you encounter a problem during the installation you may want to open up a browser and acces our github repository https://github.com/compbiomed/celda.

## Loading the library

Once installed the package can be loaded using the `library` command.

```{r,eval=FALSE}
library(celda)
```

## Finding the helpfiles
Complete list of help files are accessible using the help command with a `package` option.

```{r,eval=FALSE}
help(package=celda)
```


# 2. Single cell RNA-seq dataset analysis with celda

We will learn how to use the package `celda` to cluster genes and cells from count data generated in single cell RNA-seq experiments. `celda` will take a matrix of counts where each row is a gene and each cell is a column and each entry in the matrix is the number of counts for each gene in each cell. For this tutorial, we will start with a simple matrix of counts that were simulated according to the generative process behind the `celda_CG` model. 

```{r,eval=T, warning = FALSE, echo = FALSE}
library(devtools)
library(celda)
library(Matrix)
library(gtools)
library(ggplot2)
library(Rtsne)
library(reshape2)
```

We use the built-in data generating function `simulateCells` to simulate a single-cell RNA-Seq dataset. `simulateCells` returns a list containing a count matrix where each row is a gene and each column is a cell. The K parameter determines the number of cell clusters while the L parameter determines the number of gene clusters within the dataset. The S parameter determines the number of samples. 

```{r}
sim_counts = simulateCells("celda_CG", K = 6, L = 8, S = 10)
```

The `counts` variable contains the counts matrix.
The dimensions of counts matrix:

```{r}
dim(sim_counts$counts)
```

The `z` variable contains the cluster for each cell.
Here is the number of cells in each subpopulation:

```{r}
table(sim_counts$z)
```

The `y` variable contains the transcriptional state assignment for each gene. 
Here is the number of genes in each transcriptional state:

```{r}
table(sim_counts$y)
```

The sample.label is used to denote the sample from which each cell was derived. In this simulated dataset, we have 10 samples:

```{r}
table(sim_counts$sample.label)
```

Each cell is assumed to come from a sample. Here is the number of cells in each subpopulation within each sample:

```{r}
table(sim_counts$z, sim_counts$sample.label)
```



## 2.1.1 How to Run Celda

There are currently three models within this package: `celda_C` will cluster cells, `celda_G` will cluster genes, and `celda_CG` will simultaneously cluster cells and genes. The `celda` function will use these models and take in a counts matrix to create a `celda` object that contains the cluster labels for each cell and gene.

```{r, warning = FALSE, message = FALSE}

celda.res = celda(counts = sim_counts$counts, model = "celda_CG", K = 6, L = 9, max.iter = 10, cores = 1, nchains = 1)

```

Here is a comparison between the true cluster labels and the estimated cluster labels.

```{r}
z = celda.res$res.list[[1]]$z
y = celda.res$res.list[[1]]$y

table(z, sim_counts$z)
table(y, sim_counts$y)

```

We can display the clustering results with a heatmap of the normalized counts, obtained by the function `normalizeCounts`, which normalizes a counts matrix by a scalar factor.

```{r, fig.width = 7, fig.height = 7, warning = FALSE, message = FALSE}
norm.counts = normalizeCounts(sim_counts$counts, scale.factor = 1e6)
renderCeldaHeatmap(counts = norm.counts, z=z, y=y, normalize = NULL, color_scheme = "divergent",cluster_gene = TRUE, cluster_cell = TRUE)
```

## 2.1.2 Matrix factorization

`celda` can also perform matrix factorization to summarize the contribution of each transcriptional state to each cellular subpopulation. Matrix factorization decomposes the counts matrix into multiple matrices, using the given `celda` model. The gene.states contains each gene's contribution to the transcriptional state it belongs. The cell.states contains each sample's contribution to each transcriptional state. The population.states contains each transcriptional states' contribution to each of the cell states. Each of these matrices can be viewed as raw counts values or proportional values.

```{r}
model = getModel(celda.res, K = 6, L = 9, best = "loglik")
factorized = factorizeMatrix(model, sim_counts$count)
```

```{r}
dim(factorized$proportions$gene.states)
head(factorized$proportions$gene.states)
```

```{r}
dim(factorized$proportions$cell.states)
factorized$proportions$cell.states[1:6,1:9]
```

For instance, roughly 30% of the population in cell state K6 is in transcriptional state L2. 

```{r}
pop.states = factorized$proportions$population.states
dim(pop.states)
head(pop.states)
```

`celda` contains several plotting tools for data dimensionality reduction tool outputs. The PCA result for the factorized matrix is plotted by the `plotDrCluster` and `plotDrState` function based off of the celda clusters and state probabilities for each cell respectively:

```{r, fig.width = 7, fig.height = 7}
data.pca = prcomp(t(scale(t(factorized$proportions$cell.states))),scale = F, center = F)

plotDrCluster(dim1 = data.pca$rotation[,1], dim2 = data.pca$rotation[,2], cluster = celda.res$res.list[[1]]$z)

plotDrState(dim1 = data.pca$rotation[,1], dim2 = data.pca$rotation[,2], matrix = factorized$proportions$cell.states, rescale = TRUE)
```

The transcriptional and cell states can also be visualized with a heatmap:

```{r, fig.width = 7, fig.height = 7}
renderCeldaHeatmap(pop.states, color_scheme = "sequential", show_cellnames=T, show_genenames=T, breaks = NA, z= 1:ncol(pop.states), y = 1:nrow(pop.states))
```

Sometimes it may be helpful to visualize the relative probability of each transcriptional state in each cellular subpopulation. We can do this by z-score normalizing the probability matrix:

```{r, fig.width = 7, fig.height = 7}
rel.states = sweep(pop.states, 1, rowSums(pop.states), "/")
renderCeldaHeatmap(rel.states, color_scheme = "sequential", show_cellnames=T, show_genenames=T, breaks = NA, z= 1:ncol(rel.states), y = 1:nrow(rel.states))
```

The relative probabilities will tend to reflect the patterns observed in the heatmap as the genes in the heatmaps are Z-score transformed and thus on a relative scale as well.


## 2.1.3 Identifying the optimal number of states

The optimal number of K and L will likely not be known a priori. Therefore multiple choices of K and L may need to tested and compared. Additionally, `celda` is sensitive to initial start conditions, so it is good practice to run multiple chains for each combination of K and L to increase the chances of finding the most optimal solution. We have built a wrapper function that will run multiple combinations of K and L with multiple chains for each combination in parallel. 

```{r, eval = FALSE}
celda.res.list = celda(counts = sim_counts$counts,K = 2:4, L = 9:11, nchains = 3, max.iter = 10, model = "celda_CG", cores = 1)
```

Here, `celda` will fit the model for every combination of K between 2 and 4 and L between 9 and 11. Three chains will be run for each combination. The parameter "cores" can be set to something more than 1 to run multiple chains in parallel.

We can use the function "getModel" to select a particular model from the list of models once we have selected the optimal K and L.

```{r, eval = FALSE}
model = getModel(celda.res.list, K = 3, L = 10, best = "loglik")
```

The chain with the best log likelihood will be returned from all models that were run with K = 3 and L = 10.



# 3. Explotation of the PBMC dataset with celda

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.align = "center")
library(celda)
library(Matrix)
library(data.table)
library(pheatmap)
library(Rtsne)
```

We will now apply `celda` the "pbmc_data" dataset, which is a single-cell RNA-seq dataset of 3000 Peripheral Blood Mononuclear Cells (PBMC), available from 10X Genomics. The rows are organized by gene names, while the columns are organized by barcodes. For this tutorial, the dataset has been slightly modified so the rownames are comprised of the Ensembl gene ID as well as the gene name. The raw dataset can be found at https://support.10xgenomics.com/single-cell/software/pipelines/latest/rkit.

We will only include genes with at least 5 counts in a least 5 cells for this analysis to reduce computational time. However, `celda` is capable of analyzing genes with fewer counts. 

```{r}
dim(pbmc_data)
head(rownames(pbmc_data))
head(colnames(pbmc_data))
```

```{r}
pbmc_select = pbmc_data[rowSums(pbmc_data>4) > 4,]
```


### 3.1.1 Analysis of 10X Genomics PBMC data


```{r, eval = FALSE}
pbmc_res = celda(pbmc_select, K = 10, L = 20, cores = 1, model = "celda_CG", nchains = 8, max.iter = 100)
```

```{r}
model = getModel(pbmc_res, K = 10, L = 15, best = "loglik")
```

After matrix factorization, the top genes can be selected using the `topRank` function on the "gene.states" matrix:  

```{r}
factorize.matrix = factorizeMatrix(model, counts=pbmc_select)
top.genes = topRank(factorize.matrix$proportions$gene.states, n = 25)
```

```{r}
top.genes$names$L3
```

```{r}
top.genes$names$L9
```

We can make a heatmap of these top genes as follows: 

```{r, fig.width = 7, fig.height = 7}
top.genes.ix = unique(unlist(top.genes$index))
norm.pbmc.counts = normalizeCounts(pbmc_select)
renderCeldaHeatmap(norm.pbmc.counts[top.genes.ix,], z = model$z, y = model$y[top.genes.ix], normalize = NULL, color_scheme = "divergent")
```

We can plot tSNE results via `plotDrCluster`, `plotDrState` and `plotDrGene`. These will determine how each cell is labeled via celda, visualize each cell's expression respectively of a specific transcriptional state and visualize each cell's expression of a set of genes. 

```{r, message = FALSE}
norm_pbmc = normalizeCounts(factorize.matrix$counts$cell.states)
set.seed(123)
pbmc_tsne = celdaTsne(counts = pbmc_select, celda.mod = model)
```

With the use of the plots, it is also possible to determine which cell clusters express specific marker genes. 

```{r, fig.width = 7, fig.height = 7}
plotDrCluster(dim1 = pbmc_tsne[,1], dim2 = pbmc_tsne[,2], cluster = as.factor(model$z))

plotDrState(dim1 = pbmc_tsne[,1], dim2 = pbmc_tsne[,2], matrix = factorize.matrix$proportions$cell.states, rescale = TRUE)

marker.genes = c("ENSG00000168685_IL7R","ENSG00000198851_CD3E","ENSG00000105374_NKG7",
                 "ENSG00000203747_FCGR3A","ENSG00000090382_LYZ","ENSG00000179639_FCER1A",
                 "ENSG00000156738_MS4A1", "ENSG00000163736_PPBP")
gene.counts = pbmc_select[marker.genes,]
plotDrGene(dim1 = pbmc_tsne[,1],dim2 = pbmc_tsne[,2], matrix = gene.counts, rescale = TRUE)
```
