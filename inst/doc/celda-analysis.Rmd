---
title: "Analyzing single-cell RNA-seq count data with Celda"
author: "Josh D. Campbell, Masanao Yajima, Sean Corbett, Zichun Liu, Shiyi Yang, Tianwen Huan, Anahita Bahri, Zhe Wang, Yusuke Koga, Jiangyuan Liu"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
# Introduction
  
  "Celda" stands for "**CE**llular **L**atent **D**irichlet **A**llocation", which is a suite of Bayesian hierarchical models and supporting functions to perform gene and cell clustering for count data generated by single-cell RNA-seq platforms. This algorithm is an extension of the Latent Dirichlet Allocation (LDA) topic modeling framework that has been popular in text mining applications. Celda has advantages over other clustering frameworks:
  
1) Celda can simultaneously cluster cells into cell subpopulations and genes into gene modules - subgroups of genes that are likely to be expressed in similar proportions -  over different types of cells
2) Celda uses count-based Dirichlet-multinomial distributions so no additional normalization is required for DGE single-cell RNA-seq
3) These types of models have shown good performance with sparse data.

In this vignette we will demonstrate how to perform cell and gene clustering with simulated and real single-cell RNA-seq data using the Bayesian hierarchical models within Celda. 


# Installation Instructions

Currently Celda is hosted on a Github repository `compbiomed/celda`.

```{r,eval=FALSE}
library(devtools)
source("https://bioconductor.org/biocLite.R")
install.packages("Rcpp")
biocLite("SummarizedExperiment")
biocLite("MAST")
install_github("compbiomed/celda")
```

This should automatically install Celda on your local machine as long as you have proper internet connection.  If you have any errors in the installation or running of Celda, please post them to the Celda Github repository at https://github.com/compbiomed/celda/issues. If you have any other questions or comments, contact us on the Celda Google Group at https://groups.google.com/forum/#!forum/celda-list. 

Once installed the package can be loaded using the `library` command.

```{r,eval=FALSE}
library(celda)
```

Complete list of help files are accessible using the help command with a `package` option.

```{r,eval=FALSE}
help(package=celda)
```

<br>

# Single-cell RNA-seq dataset analysis with Celda

Celda will take a matrix of counts where each row is a gene and each cell is a column and each entry in the matrix is the number of counts for each gene in each cell. We will start with a simple matrix of counts that were simulated according to the generative process underlying the celda_CG model.

```{r,eval=T, warning = FALSE, echo = FALSE}
library(devtools)
library(celda)
library(Matrix)
library(gtools)
library(ggplot2)
library(Rtsne)
library(reshape2)
```

We use the built-in data generating function `simulateCells` to simulate a single-cell RNA-Seq dataset. In the function `simulateCells`, the K parameter designates the number of cell clusters, the L parameter determines the number of gene clusters, and the S parameter determines the number of samples in the simulated dataset.

```{r}
sim_counts <- simulateCells("celda_CG", K = 5, L = 10, S = 10)
```

The `counts` variable contains the counts matrix.
The dimensions of counts matrix:

```{r}
dim(sim_counts$counts)
```

The `z` variable contains the cluster labels for each cell.
Here is the number of cells in each subpopulation:

```{r}
table(sim_counts$z)
```

The `y` variable contains the gene module assignment for each gene. 
Here is the number of genes in each gene module:

```{r}
table(sim_counts$y)
```

The sample.label is used to denote the sample from which each cell was derived. In this simulated dataset, we have 10 samples:

```{r}
table(sim_counts$sample.label)
```

## Running the Celda function

There are currently three models within this package: `celda_C` will cluster cells, `celda_G` will cluster genes, and `celda_CG` will simultaneously cluster cells and genes. The `celda` function will use these models and take in a counts matrix to create a `celda.list` object that contains the cluster labels for each cell and gene.

```{r, warning = FALSE, message = FALSE}

celda.res <- celda(counts = sim_counts$counts, model = "celda_CG", K = 5, L = 10, max.iter = 10, cores = 1, nchains = 1)

```

The `celda.list` contains 4 objects: "run.params", "res.list","content.type",and "count.checksum". The Celda model(s) will be stored within the "res.list". 

Here is a comparison between the true cluster labels and the estimated cluster labels.

```{r}
names(celda.res)

model <- celda.res$res.list[[1]]
z <- model$z
y <- model$y

table(z, sim_counts$z)
table(y, sim_counts$y)

```

We can display the clustering results with a heatmap of the normalized counts, obtained by the function `normalizeCounts`, which normalizes a counts matrix by a scalar factor.

```{r, fig.width = 8, fig.height = 8, warning = FALSE, message = FALSE}
norm.counts <- normalizeCounts(sim_counts$counts, scale.factor = 1e6)
renderCeldaHeatmap(counts = norm.counts, z=z, y=y, normalize = NULL, 
                   color_scheme = "divergent",cluster_gene = TRUE, 
                   cluster_cell = TRUE)
```

## Matrix factorization

Celda can also perform matrix factorization to summarize the contribution of each gene module to each cellular subpopulation. Matrix factorization decomposes the counts matrix into multiple matrices, using the given Celda model. Each of these following matrices can be viewed as raw counts values, proportional values, or posterior probability values.

```{r}
factorized <- factorizeMatrix(counts = sim_counts$count, celda.mod = model)
names(factorized)
```

The gene.states contains each gene's contribution to the gene module it belongs. For our example, the matrix contains `r nrow(factorized$proportions$gene.states)` genes to 10 gene modules.

```{r}
dim(factorized$proportions$gene.states)
head(factorized$proportions$gene.states)
```

The cell.states contains each gene module's contribution to each cell subpopulation. Here, there are 10 gene modules to `r ncol(factorized$proportions$cell.states)` cells.

```{r}
dim(factorized$proportions$cell.states)
factorized$proportions$cell.states[,1:8]
```

The population.states contains each gene module's contribution to each of the cell states. Since K and L were set to be 5 and 10, there are 5 cell supopulations to 10 gene modules.

```{r}
pop.states <- factorized$proportions$population.states
dim(pop.states)
pop.states
```

## Visualization of the Celda model

Celda contains several plotting tools for data dimensionality reduction tool outputs. The PCA result for the factorized matrix is plotted by the `plotDrCluster` and `plotDrState` function based off of the Celda clusters and state probabilities for each cell respectively:

```{r, fig.width = 8, fig.height = 8}
data.pca <- prcomp(t(scale(t(factorized$proportions$cell.states))),
                   scale = F, center = F)

plotDrCluster(dim1 = data.pca$rotation[,1], dim2 = data.pca$rotation[,2], 
              cluster = celda.res$res.list[[1]]$z)

plotDrState(dim1 = data.pca$rotation[,1], dim2 = data.pca$rotation[,2],
            matrix = factorized$proportions$cell.states, rescale = TRUE)
```

In addition to the counts matrix, the transcriptional and cell states of a Celda model can also be visualized with `absoluteProbabilityHeatmap`, which may be useful in determining which cell states highly express a particular gene module. 

```{r, fig.width = 8, fig.height = 8}
absoluteProbabilityHeatmap(counts = sim_counts$counts, celda.mod = model)
```

Sometimes it may be helpful to visualize the relative probability of each gene module in each cellular subpopulation. We can do this by using `relativeProbabilityHeatmap`:

```{r, fig.width = 8, fig.height = 8}
relativeProbabilityHeatmap(counts = sim_counts$counts, celda.mod = model)
```

<br>

# Exploration of the PBMC dataset with Celda

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.align = "center")
library(celda)
library(Matrix)
library(data.table)
library(pheatmap)
library(Rtsne)
```

We will now apply Celda on the "pbmc_data" dataset, which is a single-cell RNA-seq dataset of 3000 Peripheral Blood Mononuclear Cells (PBMC), available from 10X Genomics. The rows are organized by gene names, while the columns are organized by barcodes. For this tutorial, the dataset has been slightly modified so the rownames are comprised of the Ensembl gene ID as well as the gene name. The raw dataset can be found at https://support.10xgenomics.com/single-cell/software/pipelines/latest/rkit.

To reduce computational time, we will only include genes with at least 4 counts in a least 4 cells for this analysis, which we have done already for you. However, Celda is capable of analyzing genes with fewer counts. 

```{r}
##Original pbmc_data: 7090 genes, 2700 cells
#pbmc_select <- pbmc_data[rowSums(pbmc_data>3) > 3,]

dim(pbmc_select)
head(rownames(pbmc_select))
head(colnames(pbmc_select))
```


## Identifying the optimal number of cell subpopulations and gene modules

The optimal number of K and L will likely not be known a priori. Therefore multiple choices of K and L may need to tested and compared. Additionally, Celda is sensitive to initial start conditions, so it is good practice to run multiple chains for each combination of K and L to increase the chances of finding the most optimal solution. Celda is able to run multiple combinations of K and L with multiple chains for each combination in parallel. 

```{r, eval = FALSE}
pbmc_res1 <- celda(pbmc_select,
                   K = seq(5, 50, by = 5),
                   L = seq(10, 50, by = 5),
                   cores = 1,
                   model = "celda_CG",
                   nchains = 4,
                   max.iter = 100)
```

The `calculatePerplexityWithResampling` function calculates the perplexity for every model created, which provide a distribution of perplexities which can be visualized to determine which model to use for downstream analysis. 

```{r, eval=FALSE}
calc.perplexity <- calculatePerplexityWithResampling(pbmc_res1, 
                                                     counts = pbmc_select, 
                                                     resample = 1)
```

```{r, fig.width = 8, fig.height = 8}
calc.perplexity$plot
```

We advise users to conduct a "2-pass" method for the identification of the optimal number of gene modules and cell subpopulations. For the 1st pass, we recommend users run celda on a wide range of K and L, which, upon running `calculatePerplexityWithResampling`, users can narrow down the optimal K/L combinations. Then, on the 2nd pass, users can run celda on a narrower range of K and L to determine the exact K/L combination. We are still in the process of developing a method that would make the K/L parameter selection easier.

2nd pass: 

```{r, eval = FALSE}
pbmc_res <- celda(pbmc_select, K = 10:20, L = seq(10, 50, by = 5), 
                  cores = 1, model = "celda_CG", nchains = 4, max.iter = 100)
```

From manually looking through several K/L combinations after narrowing down, it appears that K = 13 at L = 50 gives the best model. 

We can use the function `getBestModel` to select the best model with the highest log-likelihood from the list of models once we have selected the optimal K and L. The replicate with the highest log-likelihood will be returned from all models that were run with the selected K and L. 

```{r}
model.pbmc <- getBestModel(pbmc_res, K = 13, L = 50)
```

## Analysis of PBMCs with Celda

### Dimensionality Reduction
`relativeProbabilityHeatmap`, as discussed above visualizes the relationship between each gene module and cell subpopulation in a heatmap form.

```{r, fig.width = 8, fig.height = 8}
relativeProbabilityHeatmap(counts = pbmc_select, celda.mod = model.pbmc)
```

Celda supports the use of tSNE (t-stochastic neighbor embedding) via the `celdaTsne` function. We can plot these tSNE results via `plotDrCluster`, `plotDrState` and `plotDrGene`. These will determine how each cell is labeled via celda, visualize each cell's expression respectively of a specific gene module and visualize each cell's expression of a set of genes. 

```{r, message = FALSE}
factorize.matrix <- factorizeMatrix(counts=pbmc_select, celda.mod = model.pbmc)
norm_pbmc <- normalizeCounts(factorize.matrix$counts$cell.states)
set.seed(123)
pbmc_tsne <- celdaTsne(counts = pbmc_select, celda.mod = model.pbmc, distance = "hellinger")
```

With the use of the plots, it is also possible to determine which cell clusters express specific marker genes. 

```{r, fig.width = 8, fig.height = 8}
plotDrCluster(dim1 = pbmc_tsne[,1], dim2 = pbmc_tsne[,2], cluster = as.factor(model.pbmc$z))

plotDrState(dim1 = pbmc_tsne[,1], dim2 = pbmc_tsne[,2], matrix = factorize.matrix$proportions$cell.states, rescale = TRUE)

marker.genes <- c("ENSG00000168685_IL7R","ENSG00000132646_PCNA",
                  "ENSG00000105374_NKG7","ENSG00000203747_FCGR3A",
                  "ENSG00000090382_LYZ","ENSG00000153563_CD8A",
                  "ENSG00000156738_MS4A1", "ENSG00000163736_PPBP",
                  "ENSG00000101439_CST3")
gene.counts <- pbmc_select[marker.genes,]
plotDrGene(dim1 = pbmc_tsne[,1],dim2 = pbmc_tsne[,2], matrix = gene.counts, 
           rescale = TRUE)
```

### Differential Expression Analysis

Celda employs the `MAST` package [(McDavid A, 2018)](https://bioconductor.org/packages/release/bioc/html/MAST.html) for differential expression analysis of single-cell data. The `diffExpBetweenCellStates` function determines genes that are differentially expressed in one cell subpopulation against all other subpopulations, or between two cell subpopulations, which may be useful when trying to differentiate between two subpopulations with similar expression patterns.

If you wish to compare one cell subpopulation compared to all others, leave c2 as NULL: 

```{r,message=FALSE}
diff.exp.clust1 <- diffExpBetweenCellStates(counts = pbmc_select, 
                                            celda.mod = model.pbmc, 
                                            c1 = 1, c2 = NULL)

head(diff.exp.clust1,10)
```

If you wish to compare two cell subpopulations, use both c1 and c2 parameters.

```{r, message=FALSE}
diff.exp.clust1vs2 <- diffExpBetweenCellStates(counts = pbmc_select, celda.mod = model.pbmc, c1 = 2, c2 = 10)

diff.exp.clust1vs2 <- diff.exp.clust1vs2[diff.exp.clust1vs2$fdr < 0.25,]
```

The top upregulated genes in the first cluster:

```{r}
head(diff.exp.clust1vs2[order(diff.exp.clust1vs2$log2fc, decreasing = TRUE),],10)
```

The top downregulated genes in the first cluster:

```{r}
head(diff.exp.clust1vs2[order(diff.exp.clust1vs2$log2fc),],10)
```

### Heatmap Analysis

Upon matrix factorization of the counts data, the top genes in a gene module can be selected using the `topRank` function on the "gene.states" matrix:  

```{r}
factorize.matrix <- factorizeMatrix(model.pbmc, counts=pbmc_select)
top.genes <- topRank(factorize.matrix$proportions$gene.states, n = 25)
```

```{r}
top.genes$names$L42
```

```{r}
top.genes$names$L4
```

We can make a heatmap of these top genes as follows: 

```{r, fig.width = 8, fig.height = 8}
top.genes.ix <- unique(unlist(top.genes$index))
norm.pbmc.counts <- normalizeCounts(pbmc_select)
renderCeldaHeatmap(norm.pbmc.counts[top.genes.ix,], z = model.pbmc$z, 
                   y = model.pbmc$y[top.genes.ix], normalize = NULL, 
                   color_scheme = "divergent")
```

While some gene modules contribute to the identification of cell subpopulations, some states have low statistical value to the model. The `GiniPlot` function utilizes the Gini coefficient, a statistical dispersion measure, to determine the significance of each gene module.

```{r, fig.width = 8, fig.height = 8}
gini <- GiniPlot(counts = pbmc_select, celda.mod = model.pbmc)

gini
```

Users may find it useful to re-create the heatmap using only states that have a high enough Gini coefficient value to create a "cleaner" heatmap. For this example, we will use states that have a Gini coefficient higher than 0.3. This is an arbitrary cutoff, and users can set their own threshold for the cutoff. 

```{r, fig.width = 8, fig.height = 8}
filtered.tr.states <- gini$data$Transcriptional_States[gini$data$Gini_Coefficient > 0.3]

top.genes.filtered.ix <- unique(unlist(top.genes$index[as.numeric(levels(filtered.tr.states))][as.numeric(filtered.tr.states)]))

renderCeldaHeatmap(norm.pbmc.counts[top.genes.filtered.ix,], z = model.pbmc$z, 
                   y = model.pbmc$y[top.genes.filtered.ix], 
                   normalize = NULL, color_scheme = "divergent")
```

If there is a particular gene of interest, it is possible to check its gene module with the `lookupGeneModule` function.

```{r}
lookupGeneModule(counts = pbmc_select, model = model.pbmc, 
                          gene = c("ENSG00000203747_FCGR3A",
                                   "ENSG00000163736_PPBP"))
```

`stateHeatmap` creates a heatmap using only the genes from a specific gene module, which enables the visualization of co-expression patterns of genes within the gene module.

```{r, fig.width = 8, fig.height = 8, message=FALSE}
stateHeatmap(counts = pbmc_select, celda.mod = model.pbmc, state.use = 4)
```

Based off these results, we are able to assign the cell type identity to the celda cluster labels using known marker genes:

```{r table2, echo = FALSE, message = FALSE, results='asis'}
tabl <- "
| Celda Cluster | Type              | Marker     |
|---------------|:-----------------:|-----------:|
|      1        | Megakaryocytes    | PPBP       |
|      2        | CD8 T cells       | CD8A       |
|      3        | CD4 T cells       | IL7R       |
|      4        | CD4 T cells       | IL7R       |
|      5        | B cells           | MS4A1      |
|      6        | Mitochondrial     |            |
|      7        | CD4 T cells       | IL7R       |
|      8        |                   | PCNA/TUBB  |
|      9        | Dendritic cells   | CST3       |
|      10       | NK cells          | NKG7/GNLY  |
|      11       | FCGR3A+ monocytes | FCGR3A     |
|      12       | CD14+ monocytes   | LYZ/CD14   |
|      13       | CD14+ monocytes   | LYZ/CD14   |
"
cat(tabl)
```