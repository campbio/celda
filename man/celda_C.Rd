% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/celda_C.R
\name{celda_C}
\alias{celda_C}
\title{Cell clustering with Celda}
\usage{
celda_C(
  x,
  useAssay = "counts",
  sampleLabel = NULL,
  K,
  alpha = 1,
  beta = 1,
  algorithm = c("EM", "Gibbs"),
  stopIter = 10,
  maxIter = 200,
  splitOnIter = 10,
  splitOnLast = TRUE,
  seed = 12345,
  nchains = 3,
  zInitialize = c("split", "random", "predefined"),
  countChecksum = NULL,
  zInit = NULL,
  logfile = NULL,
  verbose = TRUE
)
}
\arguments{
\item{x}{A numeric \link{matrix} of counts or a
\linkS4class{SingleCellExperiment}
with the matrix located in the assay slot under \code{useAssay}.
Rows represent features and columns represent cells.}

\item{useAssay}{A string specifying which \link[SummarizedExperiment]{assay}
slot to use if \code{x} is a
\link[SingleCellExperiment]{SingleCellExperiment} object. Default "counts".}

\item{sampleLabel}{Vector or factor. Denotes the sample label for each cell
(column) in the count matrix.}

\item{K}{Integer. Number of cell populations.}

\item{alpha}{Numeric. Concentration parameter for Theta. Adds a pseudocount
to each cell population in each sample. Default 1.}

\item{beta}{Numeric. Concentration parameter for Phi. Adds a pseudocount to
each feature in each cell population. Default 1.}

\item{algorithm}{String. Algorithm to use for clustering cell subpopulations.
One of 'EM' or 'Gibbs'. The EM algorithm is faster, especially for larger
numbers of cells. However, more chains may be required to ensure a good
solution is found. If 'EM' is selected, then 'stopIter' will be
automatically set to 1. Default 'EM'.}

\item{stopIter}{Integer. Number of iterations without improvement in the
log likelihood to stop inference. Default 10.}

\item{maxIter}{Integer. Maximum number of iterations of Gibbs sampling or
EM to perform. Default 200.}

\item{splitOnIter}{Integer. On every `splitOnIter` iteration, a heuristic
will be applied to determine if a cell population should be reassigned and
another cell population should be split into two clusters. To disable
splitting, set to -1. Default 10.}

\item{splitOnLast}{Integer. After `stopIter` iterations have been
performed without improvement, a heuristic will be applied to determine if
a cell population should be reassigned and another cell population should be
split into two clusters. If a split occurs, then `stopIter` will be reset.
Default TRUE.}

\item{seed}{Integer. Passed to \link[withr]{with_seed}. For reproducibility,
a default value of 12345 is used. If NULL, no calls to
\link[withr]{with_seed} are made.}

\item{nchains}{Integer. Number of random cluster initializations. Default 3.}

\item{zInitialize}{Chararacter. One of 'random', 'split', or 'predefined'.
With 'random', cells are randomly assigned to a populations. With 'split',
cells will be split into sqrt(K) populations and then each popluation will
be subsequently split into another sqrt(K) populations. With 'predefined',
values in `zInit` will be used to initialize `z`. Default 'split'.}

\item{countChecksum}{Character. An MD5 checksum for the `counts` matrix.
Default NULL.}

\item{zInit}{Integer vector. Sets initial starting values of z. If NULL,
starting values for each cell will be randomly sampled from `1:K`. 'zInit'
can only be used when `initialize = 'random'`. Default NULL.}

\item{logfile}{Character. Messages will be redirected to a file named
`logfile`. If NULL, messages will be printed to stdout.  Default NULL.}

\item{verbose}{Logical. Whether to print log messages. Default TRUE.}
}
\value{
A \link[SingleCellExperiment]{SingleCellExperiment} object. Function
 parameter settings are stored in the \link[S4Vectors]{metadata} slot.
 Columns \code{sample_label} and \code{cell_cluster} in
 \link[SummarizedExperiment]{colData} contain sample labels and celda cell
 population clusters.
}
\description{
Clusters the columns of a count matrix containing single-cell
 data into K subpopulations.
}
\examples{
data(celdaCSim)
sce <- celda_C(celdaCSim$counts,
    K = celdaCSim$K,
    sampleLabel = celdaCSim$sampleLabel)
}
\seealso{
`celda_G()` for feature clustering and `celda_CG()` for simultaneous
 clustering of features and cells. `celdaGridSearch()` can be used to run
 multiple values of K and multiple chains in parallel.
}
