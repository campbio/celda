% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/celda_G.R
\name{celda_G}
\alias{celda_G}
\title{Feature clustering with Celda}
\usage{
celda_G(counts, L, beta = 1, delta = 1, gamma = 1, stop.iter = 10,
  max.iter = 200, split.on.iter = 10, split.on.last = TRUE,
  seed = 12345, nchains = 3, initialize = c("random", "split"),
  count.checksum = NULL, y.init = NULL, logfile = NULL,
  verbose = TRUE)
}
\arguments{
\item{counts}{Integer matrix. Rows represent features and columns represent cells.}

\item{L}{Integer. Number of feature modules.}

\item{beta}{Numeric. Concentration parameter for Phi. Adds a pseudocount to each feature module in each cell. Default 1.}

\item{delta}{Numeric. Concentration parameter for Psi. Adds a pseudocount to each feature in each module. Default 1.}

\item{gamma}{Numeric. Concentration parameter for Eta. Adds a pseudocount to the number of features in each module. Default 1.}

\item{stop.iter}{Integer. Number of iterations without improvement in the log likelihood to stop inference. Default 10.}

\item{max.iter}{Integer. Maximum number of iterations of Gibbs sampling to perform. Default 200.}

\item{split.on.iter}{Integer. On every `split.on.iter` iteration, a heuristic will be applied to determine if a feature module should be reassigned and another feature module should be split into two clusters. To disable splitting, set to -1. Default 10.}

\item{split.on.last}{Integer. After `stop.iter` iterations have been performed without improvement, a heuristic will be applied to determine if a cell population should be reassigned and another cell population should be split into two clusters. If a split occurs, then `stop.iter` will be reset. Default TRUE.}

\item{seed}{Integer. Passed to `set.seed()`. Default 12345.}

\item{nchains}{Integer. Number of random cluster initializations. Default 3.}

\item{initialize}{Chararacter. One of 'random' or 'split'. With 'random', features are randomly assigned to a clusters. With 'split' cell and feature clusters will be recurssively split into two clusters using `celda_G()` until the specified L is reached. Default 'random'.}

\item{count.checksum}{Character. An MD5 checksum for the `counts` matrix. Default NULL.}

\item{y.init}{Integer vector. Sets initial starting values of y. If NULL, starting values for each feature will be randomly sampled from `1:L`. `y.init` can only be used when `initialize = 'random'`. Default NULL.}

\item{logfile}{Character. Messages will be redirected to a file named `logfile`. If NULL, messages will be printed to stdout.  Default NULL.}

\item{verbose}{Logical. Whether to print log messages. Default TRUE.}
}
\value{
An object of class `celda_G` with the feature module clusters stored in `y`.
}
\description{
Clusters the rows of a count matrix containing single-cell data into L modules.
}
\examples{
celda.mod = celda_G(celda.G.sim$counts, L=celda.G.sim$L)
}
\seealso{
`celda_C()` for cell clustering and `celda_CG()` for simultaneous clustering of features and cells. `celdaGridSearch()` can be used to run multiple values of L and multiple chains in parallel.
}
